<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[卖萌的弱渣]]></title>
  <link href="http://sdytlm.github.io/atom.xml" rel="self"/>
  <link href="http://sdytlm.github.io/"/>
  <updated>2015-01-18T22:37:01-05:00</updated>
  <id>http://sdytlm.github.io/</id>
  <author>
    <name><![CDATA[Min Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mit6.828 Homework: Shell]]></title>
    <link href="http://sdytlm.github.io/blog/2015/01/17/shell/"/>
    <updated>2015-01-17T00:00:00-05:00</updated>
    <id>http://sdytlm.github.io/blog/2015/01/17/shell</id>
    <content type="html"><![CDATA[<h2>常用Shell 命令</h2>

<ol>
<li><code>ls &gt; y</code>
 把ls结果输出到文件y中</li>
<li><code>cat</code>
 cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用

<ul>
<li>一次显示整个文件:<code>cat filename</code></li>
<li>从键盘创建一个文件:<code>cat &gt; filename</code> 只能创建新文件,不能编辑已有文件</li>
<li>将几个文件合并为一个文件:<code>cat file1 file2 &gt; file</code></li>
</ul>
</li>
<li><code>uniq</code>
 uniq命令常用语报告或者消除文件中的重复内容，一般与sort命令结合使用</li>
<li><code>wc</code>
 wc命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls &gt; y
</span><span class='line'>cat &lt; y | sort | uniq | wc &gt; y1</span></code></pre></td></tr></table></div></figure>


<blockquote><p>功能：把当前目录ls的结果存到y中,然后读取y的内容，然后将y的内容排序，去掉重复，然后统计字数，行数.并把结果保存到y1</p></blockquote>

<!--more-->


<hr />

<h2>什么是Unix Pipeline</h2>

<p>举个例子：
<code>ls -1 | grep p | more</code>
只列出来还有字母p的当前目录下的文件</p>

<p>Pipeline 使用&#8221;|&ldquo;来区分多个命令，从左到右，前一个命令的结果是后一个命令的输入</p>

<hr />

<h2>sh.c 数据结构</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="p">{...}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">execcmd</span><span class="p">{...}</span>  <span class="c1">// 普通指令</span>
</span><span class='line'><span class="k">struct</span> <span class="n">redicmd</span><span class="p">{...}</span>  <span class="c1">// 有重定向的指令</span>
</span><span class='line'><span class="k">struct</span> <span class="n">pipecmd</span><span class="p">{...}</span>  <span class="c1">// pipe指令</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>sh.c 函数</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">runcmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">getcmd</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbuf</span><span class="p">)</span> <span class="c1">// 检测输入是否是标准输入流stdin，然后把用户输入存到buffer里</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">execcmd</span><span class="p">()</span> <span class="c1">// 为一个cmd数据结构分配内存</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">redircmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmd</span> <span class="o">*</span><span class="n">subcmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">pipecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmd</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmd</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">gettoken</span><span class="p">(</span><span class="n">chasr</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">eq</span><span class="p">)</span> <span class="c1">// 把地址ps到es的字符串中的变量找到，并存到q到eq的地址去</span>
</span><span class='line'><span class="kt">int</span> <span class="n">peek</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">toks</span><span class="p">)</span> <span class="c1">//判断从地址ps到es的字符串是否含有toks里面的字符</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">mkcopy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span> <span class="c1">// s指向需要拷贝的字符串头，es指向需要拷贝的字符串结尾. 这个函数拷贝从s到es的字符串，然后返回拷贝的地址。</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">parsecmd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="c1">// 解析命令把buffer里的命令包装成可执行的数据结构struct cmd</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">parseline</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">parsepipe</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">parsedirs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span>
</span><span class='line'><span class="k">struct</span> <span class="n">cmd</span><span class="o">*</span> <span class="n">parseexec</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>用到的C和操作系统函数</h2>

<ul>
<li><p>strchr
函数原型：extern char <em>strchr(char </em>str,char character)
参数说明：str为一个字符串的指针，character为一个待查找字符。
所在库名：#include <code>&lt;string.h&gt;</code>
函数功能：从字符串str中寻找字符character第一次出现的位置。</p></li>
<li><p>execv
函数原型：execv(char<em> cmd, char </em>argv[]);
函数说明：execv 本质上是执行命令 cmd, *argv[] 是包括argv[0]的参数
举例：
  <code>c
  execv(argv[0], argv);
 </code></p></li>
<li><p>open
 函数原型：int open(const char *pathname, int flags, mode_t mode);
 函数说明：</p>

<ul>
<li>creates a new open file description, an entry in the system-wide  table of       open files. The new open file description is initially not shared with any       other process, but  sharing  may  arise  via <strong>fork</strong></li>
<li>parameter <strong>flags</strong> must include one of the following access modes:              O_RDONLY, O_WRONLY, or O_RDWR.</li>
<li><strong>mode</strong>: 创建文件时设定的其他用户权限: S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
<code>举例说明</code>：</li>
<li>打开一个新文件用来写入</li>
</ul>


<pre><code class="`` c">  #include &lt;fcntl.h&gt;
  int fd;
  mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
  char *filename = "/tmp/file";
  fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, mode);
</code></pre>

<blockquote><p>当打开的文件不存在时 <strong>flag</strong> 必须有O_CREATE, 打开已存在文件则不需要.</p></blockquote></li>
<li><p>dup
  函数原型: int dup(int oldfd);
  函数说明: create a copy of the file descriptor oldfd</p>

<blockquote><p>dup uses the lowest-numbered unused descriptor for the new descriptor.</p></blockquote></li>
</ul>


<h2>关键部分代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">runcmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">r</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">execcmd</span> <span class="o">*</span><span class="n">ecmd</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">pipecmd</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">redircmd</span> <span class="o">*</span><span class="n">rcmd</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">cmdPath</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;/bin/&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">){</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;unknown runcmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="o">:</span>                       <span class="c1">// 普通命令</span>
</span><span class='line'>      <span class="n">ecmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">execcmd</span><span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Your code here ...</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">execv</span><span class="p">(</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">// 到/bin目录中找命令</span>
</span><span class='line'>          <span class="kt">char</span> <span class="n">cmdPath</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;/bin/&quot;</span><span class="p">;</span>
</span><span class='line'>          <span class="n">strcat</span><span class="p">(</span><span class="n">cmdPath</span><span class="p">,</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>          <span class="k">if</span><span class="p">(</span><span class="n">execv</span><span class="p">(</span><span class="n">cmdPath</span><span class="p">,</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">){</span>   <span class="c1">// test /bin/cmd</span>
</span><span class='line'>              <span class="kt">char</span> <span class="n">cmdPath2</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;/usr/bin/&quot;</span><span class="p">;</span>
</span><span class='line'>              <span class="n">strcat</span><span class="p">(</span><span class="n">cmdPath2</span><span class="p">,</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>   <span class="c1">// test /usr/bin/cmd (e.g.sort)</span>
</span><span class='line'>              <span class="k">if</span><span class="p">(</span><span class="n">execv</span><span class="p">(</span><span class="n">cmdPath2</span><span class="p">,</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>                  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Command %s not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ecmd</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>              <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;&gt;&#39;</span><span class="o">:</span>                       <span class="c1">// 重定向命令</span>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;&lt;&#39;</span><span class="o">:</span>
</span><span class='line'>        <span class="n">rcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">redircmd</span><span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">//fprintf(stderr, &quot;redir not implemented\n&quot;);</span>
</span><span class='line'>        <span class="c1">// Your code here ...</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">rcmd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>     <span class="c1">// 重定向命令已经默认的fd指向了0或1，所以这里是关闭stdin 或者 stdout</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">open</span><span class="p">(</span><span class="n">rcmd</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span><span class="n">rcmd</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRGRP</span><span class="o">|</span><span class="n">S_IROTH</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;Cannot open file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">runcmd</span><span class="p">(</span><span class="n">rcmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">case</span> <span class="sc">&#39;|&#39;</span><span class="o">:</span>                      <span class="c1">//  管道线命令</span>
</span><span class='line'>        <span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pipecmd</span><span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// fprintf(stderr, &quot;pipe not implemented\n&quot;);</span>
</span><span class='line'>        <span class="c1">// Your code here ...</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
</span><span class='line'>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;Create pipe failes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// 子进程把pipe的right end 和 标准输出连起来</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">fork1</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 标准输出被赋予fd:p[1]</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">// 这样fd表里只剩下标准输入fd:0 和输出fd:p[1]</span>
</span><span class='line'>            <span class="n">runcmd</span><span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">fork1</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 标准输入被赋予fd:p[0]</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 这样fd表里只剩下标准输入fd:fd[0] 和 输出fd:p[0]</span>
</span><span class='line'>            <span class="n">runcmd</span><span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">wait</span><span class="p">();</span> <span class="c1">// 父进程等待子进程结束。</span>
</span><span class='line'>        <span class="n">wait</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mit6.828 Chapter 0: Operating System Interfaces]]></title>
    <link href="http://sdytlm.github.io/blog/2015/01/17/os1/"/>
    <updated>2015-01-17T00:00:00-05:00</updated>
    <id>http://sdytlm.github.io/blog/2015/01/17/os1</id>
    <content type="html"><![CDATA[<p><strong>Process</strong>: include memory containing instructions, data and a stack. <strong>Instructions</strong> implement the program&rsquo;s computation. The <strong>data</strong> are the variables on which the computation acts. The <strong>stack</strong> organizes the program&rsquo;s procedure calls.</p>

<blockquote><p>Procedure calls： 也叫系统调用，用来给process调用kernel service. 当process调用系统调用时，硬件cpu会提高程序的privilege level然后执行内核中已经定义好的函数.</p></blockquote>

<!--more-->


<h3>Processes and Memory</h3>

<ul>
<li>xv6 进程包括<strong>user-space memory</strong>和<strong>per-process state</strong> private to the kernel.</li>
<li>当进程不工作时保存CPU Register，下次启动时再restore.</li>
<li><p>一个进程可以调用fork system call来生成一个新进程叫<strong>child process</strong>. 原来那个进程叫<strong>parent process</strong>.</p>

<blockquote><p>child process 有父进程的memory content.</p></blockquote></li>
<li><p>fork system call returns in both parent and child.</p></li>
</ul>


<blockquote><p>In the parent process, fork returns the child&rsquo;s pid. In the child, it returns 0.</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int pid = fork();
</span><span class='line'>    if(pid > 0){
</span><span class='line'>        printf("parent: child=%d\n", pid);
</span><span class='line'>        pid = wait();
</span><span class='line'>        printf("child %d is done\n", pid);
</span><span class='line'>    } else if(pid == 0){
</span><span class='line'>        printf("child: exiting\n");
</span><span class='line'>        exit();
</span><span class='line'>    } else {
</span><span class='line'>        printf("fork error\n");
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<pre><code>输出结果是

```
    parent: child=1234
    child: exiting
    注：输出结果的顺序可能不同，取决于child 和 parent谁先执行
```
&gt; 注意：parent process 和 child process 执行在不同的内存和寄存器中，修改其中的一个变量不会影响到另一个进程的执行
</code></pre>

<ul>
<li><p><strong>exec(filename, *argv)</strong> system call: 从file system 加载指定文件到进程的内存中. 在xv6中，文件格式为ELF. exec执行以后，不会反回原进程，而是继续从载入的文件开始执行.</p>

<pre><code class="`` c++">  argv[0] = "echo"; // 会被忽略
  argv[1] = "hello";
  argv[2] = 0;
  exec("/bin/echo", argv);
  printf("exec error\n");
</code></pre>

<blockquote><p>第一个变量argv[0]会被忽略，不起实际作用</p></blockquote></li>
<li><p>Xv6 shell的执行流程:</p>

<ol>
<li> shell 执行 <strong>getcmd</strong> 获得用户输入的命令</li>
<li> shell 执行 <strong>fork</strong> 创建一个shell 进程的copy,然后shell进入wait状态</li>
<li> shell 执行 <strong>runcmd</strong> 运行用户的命令</li>
<li> runcmd函数调用<strong>exec</strong> 系统调用加载适当的函数如：echo</li>
<li> 在函数(echo) 的结束，有<strong>exit</strong>系统调用返回shell, shell从wait中退出</li>
</ol>
</li>
</ul>


<blockquote><p>xv86为用户分配内存空间: <strong>fork</strong>为子进程copy父进程的内存,<strong>exec</strong> 为可执行文件ELF开辟内存, 当用户需要额外内存时(malloc) 调用<strong>sbrk(n)</strong></p></blockquote>

<hr />

<h3>I/O and File Descriptors</h3>

<ul>
<li><p>File Descriptor: a small integer representing a kernel-managed object that a process may read from or write to.</p>

<blockquote><p>xv6中，所有的object都有file descriptor</p></blockquote></li>
<li><p>每一个进程都有private file descriptor table.</p></li>
<li><strong>read(fd,buf,n)</strong>系统调用: 读取fd中n个bytes到buf. 每个fd中都有一个<strong>offset</strong>，读取一次都会update offset，以便下次继续读取. 若没什么可读了，返回0，否则返回读取的字节数.</li>
<li><p><strong>write(fd,buf,n)</strong>系统调用： 向fd中写入buf里的n个bytes. 工作原理与read类似，也有<strong>offset</strong>
举例（Cat的实现）：</p>

<pre><code class="`` c">  char buf[512];
  int n;
  for(;;){
      n = read(0, buf, sizeof (buf));  // 从标准输入读
      if(n == 0)                       // 输入结束
          break;
      if(n &lt; 0){                       // error
          fprintf(2, "read error\n");
          exit();
      }
      if(write(1, buf, n) != n){      // 向标准输出写
          fprintf(2, "write error\n");
          exit();
      }
  }
</code></pre></li>
<li><p>close 系统调用会释放一个file descriptor。 当有进程申请新的file descriptor时，<strong>数值最小的那个fd</strong>会被分配给新的object.</p></li>
<li><p>实现 I/O 重定向: 先用close释放一个file descriptor，然后重新open一个文件，这样新的文件就拥有了释放掉的fd(因为总是从最小的fd开始分配).</p>

<p>  举例（实现cat &lt; tinput.txt)：</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;cat&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 确保是在子进程里</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// 释放fd 0</span>
</span><span class='line'>    <span class="n">open</span><span class="p">(</span><span class="s">&quot;input.txt&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span> <span class="c1">// assign fd0 to input.txt</span>
</span><span class='line'>    <span class="n">exec</span><span class="p">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>           <span class="c1">// 执行cat命令</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code> &gt; Fork 拷贝父进程的file descriptor table 到子进程. exec在载入文件时依然会保留进程的file descriptor table.
</code></pre>

<ul>
<li><p>当父子进程同时操作一个fd时，fd中的offset是共享的.</p>

<pre><code class="`` c">  if(fork() == 0) {
      write(1, "hello ", 6);
      exit();
  } else {
      wait();                  // 确保先执行子进程再执行父进程
      write(1, "world\n", 6);
  }
</code></pre>

<blockquote><p>父进程写的word不会覆盖子进程写的hello. 因为offset是共享的.</p></blockquote></li>
<li><p><strong>dup</strong>系统调用: 复制当前fd，返回一个新的fd指向同一个Object. dup出来的新fd共享之前fd的offset
  <code>c
  fd = dup(1);                // 复制fd 1
  write(1, "hello ", 6);
  write(fd, "world\n", 6);
 </code></p>

<blockquote><p>在不创建子进程的情况下，通过dup实现共享offset。除此之外offset不能共享</p></blockquote></li>
</ul>


<hr />

<h3>Pipes</h3>

<p>实现一个简单的Pipe, wc 连接pipe的read end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;wc&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 创建pipe，在p中记录read和write fd</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 子进程</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>    <span class="c1">// fd0 被赋给p[0]指向的object</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">// p[1]必须在wc之前被close, 否则read end就不会结束</span>
</span><span class='line'>    <span class="n">exec</span><span class="p">(</span><span class="s">&quot;/bin/wc&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span> <span class="c1">// execute wc on p[0]</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>         <span class="c1">// 父进程</span>
</span><span class='line'>    <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> <span class="c1">// execute &quot;write hello world to p[1]&quot;</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>上面代码中, p[0]: read end, p[1]: write end . 子进程必须在wc之前关闭p[1], 否则wc时read end一直等待所有指向write end的fd关闭.</p></blockquote>

<ul>
<li>如果pipe的read end没有数据, 则read end 要么是等待数据,要么等待所有指向write end的fd都关闭. 若后一种情况发生时，读到的是0，表示读到文件的结束了.</li>
<li>如何实现<code>fork sh.c | wc -l</code>

<ul>
<li>child process creates a pipe to connect the left end of the pipe with the right end.</li>
<li>child process calls <strong>runcmd</strong> for the left end of the pipeline</li>
<li>child process calls <strong>runcmd</strong> for the right end of the pipe</li>
<li>waits for the left and the right ends to finish by calling <strong>wait</strong> twice</li>
</ul>
</li>
<li>pipe 和 temp file的不同之处:

<ul>
<li>pipe 可以自动清理</li>
<li>tmp file需要空间，pipe不需要空间，传递的是data stream</li>
<li>pipe 可以 synchronization,一个process可以block read等到另一个process写完pipe，再读取.</li>
</ul>
</li>
</ul>


<hr />

<h3>File System</h3>

<ul>
<li><strong>chdir</strong> 系统调用: 改变当前工作目录</li>
<li><strong>mkdir</strong> 系统调用: 创建一个新的目录, 用<strong>open</strong>系统调用可以创建新的文件</li>
<li><p><strong>mknod</strong> 系统调用: 创建新的设备文件</p>

<pre><code class="`` c">  // chdir
  chdir("/a");
  chdir("b");
  open("c", O_RDONLY);
  // 另一种实现方法
  open("/a/b/c", O_RDONLY);

  // mkdir
  mkdir("/dir");
  fd = open("/dir/file", O_CREATE|O_WRONLY); // 创建文件
  close(fd);

  // mknod
  mknod("/console", 1, 1); // 这两个数字分别是major and minor device number. 用来识别kernel deviced
</code></pre></li>
<li><p><strong>fstat</strong> 系统调用: 可以读取一个fd指向的object的信息. fstat 读取的数据结构定义如下</p>

<pre><code class="`` C">  #define T_DIR 1 // Directory
  #define T_FILE 2 // File
  #define T_DEV 3 // Device
  struct stat {
      short type; // Type of file
      int dev; // File system’s disk device
      uint ino; // Inode number, OS里用来识别真实文件的, 一个innode 可以被Link到多个名字去
      short nlink; // Number of links to file
      uint size; // Size of file in bytes
};
</code></pre></li>
<li><p><strong>link</strong> 和 <strong>unlink</strong> 系统调用: 为已存在的文件创建一个“别名”，但是都指向相同的Innode.</p>

<pre><code class="`` C">  open("a", O_CREATE|O_WRONLY);
  link("a", "b");
  unlink("a");
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
