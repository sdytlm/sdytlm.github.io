# C Study Note II

标签（空格分隔）： C

---

## 目录
[TOC]

## Chapter 2: Types, Operators and Expressions

### 变量名定义
* 必须以字母开头
* 大小写敏感
* 函数名和外部变量名长度小于31

---

### 变量的长度 
* short int, int, long int
    > short <= int < long

    short 和 int 至少16bit, long 至少32 bit

* signed char, unsigned char 
    signed 和 unsigned也可以用于其他integer
    > unsigned char: 0 ~ 255 因为char是8 bit
      signed char : -128 ~ 127

---
### 常量
下面的表中全是常量，并且后缀和前缀不区分大小写
| 格式 | 解释|
|----------|----------|
| 1234L | long constant 1234|
| 1234U | unsigned int 1234|
| 1234UL | unsigned long 1234|
| 123.4 or (1e-2) | double |
| 123.4F | float 123.4 |
| 123.4L | long double 123.4|
| 037 | 八进制数表示十进制31|
| 0x1f| 16进制数表示十进制31|
| 0xfUL| unsigned long 16进制表示十进制15|
| 'x' | 字符型常量x, 对应一个int数，在计算时，会被转成int型|
|'\000'| 8进制数对应的char, 000可以是任意八进制数. 如: '\013' 对应ASCII vertical tab|
| '\xhh'| 16进制数对应的char， hh可以是任意16进制数, 如: '\xb' 对应ASCII vertical tab|
| "hello, word" | 字符串常量，最后以'\0'结尾。 |
> '\0'所对应的Int值也是0

注:
> 字符串常量所需的存储空间比字符数多1 （'\0'）。
**strlen(s)** 可以返回'\0'之前的字符数.

* Enumeration constant
    **enum enumeration的名字 ｛name = value ｝**
    例如： 

    ``` c
    enum boolean {NO, YES};
    enum escapes {BELL = '\a', BACKSPACE = '\b'};
    enum months {JAN = 1, FEB, MAR}; // FEB = 2， MAR = 3
    ```
> name 必须不同, value可以相同. 
 value的值可以没有(默认从0开始给name赋值), 若前面name有值，则累加

--- 
### Declaration
* external 和 static 变量被初始化成0
* const 用于变量声明以后，任何函数不能修改该变量

---
### Operators
* % 不能用于float 和 double型变量
* || 和 && 会在结果确定以后就停止, 如: false && a==b 中 a==b不会被Judge
* ! 操作把非0的转成0，把0转成1 

---
### Type Conversions
一般来说， 要把一个narrower 的操作数转换成一个 wider的操作数，以防止丢失信息.

* 实现把string 转换成int

    ``` c
    int atoi(char s[]) {
        int i,n=0;
        for(i=0;s[i]>='0' && s[i] <='9'; ++i) 
            n = 10*n + (s[i]-'0');      // s[i] - '0' 会得到一个numeric value， 因为'0','1'，etc. 是一个连续增长的char
        return n;
    }
    ```

* `<ctype.h>` 中定义了许多和type有关的操作
    ``` c
    tolower(char): 用来把upperletter 变成 lowerletter
    isdigit(char): 判断char是否在'0' ~ '9'范围内 
    ```
    
* 当char 被自动转换成Int 时， 有没有可能出现负数？ 不同机器不同，有的会有负数， 有的会在第一位加0
* 在做算数运算时，lower type 会转成 higher type
    * if operand is **long double**, convert the other to **long double**.
    * if either operand is **double**, convert the other to **double**.
    * if either operand is **float**, convert the other to **float**.
    * if either operand is **long**, convert the other to **float**.
    * convert **char** and **short** to **int**
> float 不会转成 double

* 赋值时发生type conversion
    * 长的数转换成短的数会造成数据丢失,下面这个例子中如何i和c的赋值顺序倒过来，i的数据就会丢失因为 int 比 char 长
    ``` c
    int i;
    char c;
    
    i = c;  // c=i;
    c = i   // i=c;
    ```
* 函数调用时发生 type conversion。 例如函数定义为sqrt(double) 调用时 root = sqrt(2)。 则这个 “2”会被自动转换成double型
* 还可以显示的使用 **(type name) expression** 来改变类型. 比如：sqrt((double) n) 会把n转换成double型. 

---
### i++和++i
* ++n: increments n before its value is used.
* n++: increase n after its value has been used. 

``` c
if(s[i] != c)
    s[j++] = s[i];
```
等价于
``` c
if(s[i] != c) {
    s[j] = s[i];
    j++;
}
```
* strcat(s,t): 把string t 接到string s 后面就利用了这个性质

``` c
void strcat (char s[], char t[])
{
    int i,j;
    i = j = 0;
    while (s[i]!='\0')
        i++;
    while((s[i++] = t[j++]) != '\0') // 先把s[j] 给 s[i] 然后i++， j++
        ;
}
```
---
### bit操作及优先级相关
* ^ 位操作: 相同为0，不同为1
* << 和 >> 操作只对正数有效
* shift 一个有符号数，是填0还是填1，不好说
* **~0 << n**: 最右边n位为0.
* x \*= y+1  =====> x = x\*(y+1)
* &, ^运算的优先级低于 == , !=. 所以 (x & mask)==0的括号不能省略.
* 有时，运算的优先级是无法确定的。
    * x = f() + g()。 不知道那个函数先被调用
    * printf("%d %d\n", ++n, power(2,n)); 实际上++n 不能确定先执行
    * a[i] = i++ 很难确定左边还是右边先执行.