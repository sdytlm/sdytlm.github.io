# Operating System II

标签（空格分隔）： mit6.828

---

## 目录
[TOC]


## Chapter 1: Operating System Organization 
操作系统的3个目标：Multiplexing, Isolation, Interaction
下面就是简单介绍一下如何实现如上3个目标

###  Abstract Physical Resources
为什么OS要用系统调用 (fork,exec etc.) 和 file descriptor 来 abstract resources 而不是让 application 自己 access raw resources?
**答**： 因为要实现 isolation. 不能 trust Process.

### User Mode, Kernel Mode and System Calls
* X86 processors 提供了两种Mode: **Kernel Mode** and **User Mode**. Privileged instruction 只能在 kernel mode 执行, 若 application 要执行 privileged instruction (e.g. read, write), CPU 会切换到 kernel mode. 由内核的代码来完成.

* X86 processors 提供了一个特别的指令 **int** 给application, 完成 user mode 到 kernel mode 的转换. Kernel 需要确保 kenel mode 的 entry point 是正确的.

### Kernel Organization
Monolithic Kernel VS Microkernels:Monolithic kernels 把所有 kernel 相关的都运行在 kernel mode. Microkernel 会在 user mode 实现一部分 OS 功能(e.g. file system)

### Process Overview
X86 uses page tables (implemented by hardware) to give each process its own address space. 
![image](https://copy.com/ja9F8iw4hYNnPoQK)

In the above figure, 每个进程的地址都从**虚拟地址 0x0**开始.head 用来给 process expand 空间(malloc), 进程地址空间映射了 kernel instructions and data starting at **0x80100000**. 这么设计的原因是为了方便 kernel system call 直接访问 user memory.

* kernl maintains many pieces of state for each process in a struct **proc** including page table, kernel stack and run state. 
* Each Process has a thread of execution that executes the process's instructions. 
* Each process has two stacks: **user stack and kernel stack (p->kstack)**, 当进程在 user mode 时, 使用 user stack. 当进程进入 kernel mode 以后，开始使用 kernel stack, user stack 用来记录保存的数据
* **p->state**: whether the process is allocated, ready to run, running, waiting for I/O, or exiting
* **p->pgdir**: holds the process's page table, 这个指针需要被送给 paing hardware.

### The First Address Space

* Boot loader 把xv6 kernel 加载到物理地址**0x100000**.
    问: 为啥不是加载到物理地址0x80100000?
    答: 不是所有机器都有那么高的内存
    问: 为啥不是加载到0x00?
    答: [0xa0000-0x100000] 包含I/O devices.
* 创建 page table 映射虚拟地址**0x80000000 (aka KERNBASE)** 到物理地址0x0. 见下图
    ![image](https://copy.com/nctujktZRJJdMCa2)

* Page table中 entry 0 映射**虚拟地址 0:0x400000 to 物理地址 0:0x400000**. Entry 512 映射**虚拟地址 KERNBASE:KERNBASE+0x400000 to 物理地址 0:0x400000**  
* 把page table 的物理地址**entrypgdir**加载到 cr3 寄存器中, 这个物理地址是通过**V2P_WO - KERNBASE**计算出来的. 然后打开CR0 的 Page Flage.
*  Make **esp** 指向一个stack,这个stack位于高地址空间,然后通过间接跳转到这个stack。